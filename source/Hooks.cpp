#include "Hooks.h"

#include "Data.h"

namespace Addresses
{
    struct DeathHandler 
    {
        static bool thunk(RE::Character* a_target, RE::Character* a_source)
        {
            if (a_target == RE::PlayerCharacter::GetSingleton()) {
                const auto save_manager = RE::BGSSaveLoadManager::GetSingleton();

                if (save_manager) {
                    Data::BuildSaveGameList(save_manager);

                    const auto save_files = Data::GetSingleton()->GetSaveFileDirectory();

                    if (!save_files) { stl::report_and_fail("Failed to obtain save files path!"); }

                    const auto source_name = a_source ? a_source->GetName() : "???";
                    const auto target_name = a_target->GetName();
                    const auto target_race = a_target->GetRace()->GetName();
                    const auto target_level = a_target->GetLevel();
                    const auto location_name = a_target->GetCurrentLocation()->GetName();
                    const auto days_passed = std::floorf(RE::Calendar::GetSingleton()->GetDaysPassed());

                    Data::GetSingleton()->QueueMessage(source_name, target_name, location_name, target_race, target_level, days_passed);

                    try {
                        if (std::filesystem::exists(*save_files)) {
                            std::ofstream output("Data/SKSE/Plugins/ad-mortem-permadeath-engravings.txt", std::ios::app);

                            if (output.is_open()) {
                                output << "-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-\n\n";
                                output << std::vformat(Settings::Message, std::make_format_args(source_name, target_name, location_name, target_name, target_name, target_race, target_level, days_passed, ""sv));
                                output << "-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-=x=-\n\n";

                                for (const auto& file : save_manager->saveGameList) {

                                    /*
                                        * Ignore save files from characters that weren't properly initialized, 
                                            i.e characters that are results from a 'coc' or related command called from the Main Menu
                                    */

                                    if (save_manager->currentID == 0x0) { continue; };

                                    if (file->characterID == save_manager->currentID) {

                                        for (const auto& entry : std::filesystem::directory_iterator(*save_files)) {
                                            if (entry.path().stem() == file->fileName.data()) {
                                                logger::info("Addresses::DeathHandler :: Deleting file: '{}'", entry.path().filename().string());

                                                std::filesystem::remove(entry);
                                            }
                                        }
                                    }
                                }

                                output.close();
                            }
                        }
                    } catch (const std::filesystem::filesystem_error& error) {
                        stl::report_and_error(error.what());
                    }
                }
            }

            return func(a_target, a_source);
        }
        static inline REL::Relocation<decltype(thunk)> func;
    };

    /*
        * Although a bit unlikely to happen,
            we are blocking input for Quicksave/Quickload calls while the player is in the death scene to ensure no files are accessed while they are getting processed for deletion.
    */

    struct CanProcess
    {
        static bool thunk(RE::QuickSaveLoadHandler* a_handler, RE::InputEvent* a_event)
        {
            const auto player = RE::PlayerCharacter::GetSingleton();

            if (player && player->IsDead()) {
                return false;
            }

            return func(a_handler, a_event);
        }
        static inline REL::Relocation<decltype(thunk)> func;
    };

    /* 
        * When creating a new character by using the 'New Game' option in the main menu, a random ID will be assigned to that character for as long as it stays loaded. 
            That same ID is going to be assigned to that character's related save files when they get generated by the save/load manager.

        * Loading the game by using the 'Load Game' option would restore such ID correctly, 
            however this process does not happen if we create a new default character by calling the 'coc' console command while in the Main Menu,
            doing so does not make the game regenerate a ID for the newly created default character, keeping the latest used ID loaded in memory instead.

        * This becomes a problem if we had previously loaded a save file, quit to the Main Menu and then called the 'coc' command afterwards,
            doing so would make the game assign the previously loaded character id to the newly created default character related save files, if we ever save while playing in it. 
            If such default character died, all of the previously loaded character related save files would get deleted as well because both character would be sharing the same ID now.

        * To avoid that, we reset the current ID the game has loaded in memory when a 'coc', 'coe' or 'cow' command is called from the Main Menu.
    */

    struct CenterOnCell
    {
        static bool thunk(RE::PlayerCharacter* a_player, const char* a_cellName, RE::TESObjectCELL* a_cell)
        {
            const auto ui_manager = RE::UI::GetSingleton();

            if (ui_manager && ui_manager->IsMenuOpen(RE::MainMenu::MENU_NAME)) {
                const auto save_manager = RE::BGSSaveLoadManager::GetSingleton();

                save_manager->currentID = 0x0;
                save_manager->unk0D4 = 0x0;
            }

            return func(a_player, a_cellName, a_cell);
        }
        static inline REL::Relocation<decltype(thunk)> func;
    };

    struct CenterOnExterior
    {
        static bool thunk(RE::PlayerCharacter* a_player, const char* a_cellName, RE::TESObjectCELL* a_cell)
        {
            const auto ui_manager = RE::UI::GetSingleton();

            if (ui_manager && ui_manager->IsMenuOpen(RE::MainMenu::MENU_NAME)) {
                const auto save_manager = RE::BGSSaveLoadManager::GetSingleton();

                save_manager->currentID = 0x0;
                save_manager->unk0D4 = 0x0;
            }

            return func(a_player, a_cellName, a_cell);
        }
        static inline REL::Relocation<decltype(thunk)> func;
    };

    struct CenterOnWorld
    {
        static bool thunk(RE::PlayerCharacter* a_player, const char* a_cellName, RE::TESObjectCELL* a_cell)
        {
            const auto ui_manager = RE::UI::GetSingleton();

            if (ui_manager && ui_manager->IsMenuOpen(RE::MainMenu::MENU_NAME)) {
                const auto save_manager = RE::BGSSaveLoadManager::GetSingleton();

                save_manager->currentID = 0x0;
                save_manager->unk0D4 = 0x0;
            }

            return func(a_player, a_cellName, a_cell);
        }
        static inline REL::Relocation<decltype(thunk)> func;
    };

	void Hook()
	{
        REL::Relocation<std::uintptr_t> death_handler{ RELOCATION_ID(36872, 37896), REL::Relocate(0x588, 0x5F8) };
        stl::write_thunk_call<DeathHandler>(death_handler.address());

        logger::info("Addresses :: Hooked DeathHandler");

        stl::write_vfunc<RE::QuickSaveLoadHandler, 0x1, CanProcess>();

        logger::info("Addresses :: Hooked QuickSaveLoadHandler::CanProcess");

        REL::Relocation<std::uintptr_t> center_on_cell{ RELOCATION_ID(22398, 22873), 0x5B };
        stl::write_thunk_call<CenterOnCell>(center_on_cell.address());

        logger::info("Addresses :: Hooked CenterOnCell");

        REL::Relocation<std::uintptr_t> center_on_exterior{ RELOCATION_ID(22400, 22875), REL::Relocate(0x118, 0x109) };
        stl::write_thunk_call<CenterOnExterior>(center_on_exterior.address());

        logger::info("Addresses :: Hooked CenterOnExterior");

        REL::Relocation<std::uintptr_t> center_on_world{ RELOCATION_ID(22401, 22876), REL::Relocate(0x108, 0x104) };
        stl::write_thunk_call<CenterOnWorld>(center_on_world.address());

        logger::info("Addresses :: Hooked CenterOnWorld");
	}
}